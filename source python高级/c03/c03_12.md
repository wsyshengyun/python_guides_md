# 3.12 静态方法其实暗藏玄机

![](http://image.iswbm.com/20200602135014.png)

静态方法，应该没人不知道吧？

它可以算是一个很基础、简单的知识点。

但是就是这样一个知识点，也有不少可以探究的东西。

不信我问你三个问题，你看能否答上来。

1. Python2.x和3.x中，函数和方法的区分有什么不同？
2. 有了类/实例方法和普通函数，为什么还会有静态方法？
3. Python3.x 中，静态方法有几种写法？

如果你没能答上来，那你可以尝试在下文中寻找答案。

---

在 Python 2 中的函数和方法的区别，十分清晰，很好分辨。但在 Python3中，我却发现完全又是另一套准则。

首先先来 Python2 的（以下在 Python2.7中测试通过）

![](http://image.iswbm.com/20190630111243.png)

可以得出结论：

1、普通函数（未定位在类里），都是函数。

2、静态方法（@staticmethod），都是函数。

3、类方法（@classmethod），都是方法。

4、实例方法（首参数为self且非静态、非类方法的），都是方法。

你一定想说，类方法和实例方法，是方法没错呀，毕竟名字本身就有方法，普通函数是函数，我也理解呀。那静态方法，为什么不是方法而是函数呢？

名字只是一个外在的表面称呼，你能说「赵铁男」就一定是汉子吗？

我的理解是：方法是一种和对象（实例或者类）绑定后的函数。

类方法的首参是`cls`，调用时，无需显示传入。实例方法首参是self，调用时，也无需显示传入。

而静态方法，其实和普通函数没啥区别，唯一的区别就是，他定义的位置被放在了类里，做为类或者实例的一个函数。

那你肯定又要问了，既然静态方法和普通函数都是一样的，为什么要刻意将它放在类里呢？

我上面说了，放在类里定义，就可以让它成为类的一个工具函数，这就像你身上随身携带了一把刀，这把刀与你本人并没有什么直接关系，唯一的联系就是这把刀是你的，而你把它带在身上，无论你去到哪里，只要需要，你就可以直接拿出来用上。对比将函数放在类外面，缺点是什么呢？就是当你出门在外（在别的模块里）发现你要用刀的时候，还要特地跑一趟去商店买一把刀（import 这个函数）。

另外，我觉得静态方法在业务和设计上的意义，会更多一些。

一般静态方法是做为类或者实例的一个工具函数，比如对变量的做一个合法性的检验，对数据进行序列化反序列化操作等等。

说完了 Python2 ，再来说说Python3.

以前我觉得 Python2 对于方法和函数的界线更加清晰，但接触了 Python3，我反而觉得Python3里方法和函数的区分似乎更加合理。

还是刚刚那段代码，我更改了解释器为Python3.6（以下在 Python3.6中测试通过）

![](http://image.iswbm.com/20190630104956.png)

和Python2的唯一区别是，`People.jump` 在Python3 中变成了函数。

这一下颠覆了你刚刚才建立起来的知识体系有木有？

先别急，我再做个试验，也许你就知道了。

**在 Python2中**

执行People.jump('hello')，会报错说，jump的首参必须为People的实例对象，这可以理解，毕竟jump定义时，第一个参数为self。

![](http://image.iswbm.com/20190630105735.png)

**在 Python3中**

你可以发现，这里的jump的首参不再要求是 People 的一个实例，而可以是任意的对象，比如我使用字符串对象，也没有报错。

![](http://image.iswbm.com/20190630105600.png)

也就是说，当你往jump中传入的首参为People的实例时，jump 就是方法，而当你传入的首参不是People的实例对象时，jump就是函数。

你看，多么灵活呀。

再总结一下，在Python3中：

1、普通函数（未定位在类里），都是函数。

2、静态方法（@staticmethod），都是函数。

3、类方法（@classmethod），都是方法。

4、方法和函数区分没有那么明确，而是更加灵活了，一个函数有可能是方法也有可能是函数。

你肯定又要问了，那这是不是就意味着，Python3 中静态方法，可以不用再使用@staticmethod 装饰了呢，反正Python3都可以识别。

这是个好问题，是的，可以不用指定，但是最好指定，如果你不指定，你调用这个方法只能通过People.jump，而不能通过 self.jump了，因为首参不是 self，而如果使用@staticmethod 就可以使用self.jump。

所以说这是一个规范，就像类的私有方法，规范要求外部最好不要调用，但这不是强制要求，不是说外部就不能调用。

写这篇文章的起源，是前两天有位读者在交流里问到了相关的问题，正好没什么主题可以写，就拿过来做为素材整理一下，也正好没有写过静态方法、类方法的内容，没想到简单的东西，也能写出这么多的内容出来。



![](http://image.iswbm.com/20200607174235.png)

